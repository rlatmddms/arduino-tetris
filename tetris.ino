#include <LedControl.h>

LedControl lc = LedControl(12, 10, 11, 4); // DIN, CLK, CS, 장치 수

char board[8][32] = {"00000000000000000000000000000000",
                     "00000000000000000000000000000000",
                     "00000000000000000000000000000000",
                     "00000000000000000000000000000000",
                     "00000000000000000000000000000000",
                     "00000000000000000000000000000000",
                     "00000000000000000000000000000000",
                     "00000000000000000000000000000000"};
char READY[8][32] = {"11110011111001110011110010001011",
                     "10001010000011011010011011011011",
                     "10001010000010001010001001010011",
                     "10010011111010001010001001110011",
                     "11100010000011111010001000100011",
                     "10010010000010001010001000100000",
                     "10001010000010001010011000100011",
                     "10001011111010001011110000100011"};
                    //00000000111111110000000011111111
const char blocks[7][4][4][4]={	//
{{{'0','0','0','0'},{'1','1','1','1'},{'0','0','0','0'},{'0','0','0','0'}},	//0 번 I형 블록
 {{'0','0','1','0'},{'0','0','1','0'},{'0','0','1','0'},{'0','0','1','0'}},
 {{'0','0','0','0'},{'1','1','1','1'},{'0','0','0','0'},{'0','0','0','0'}},
 {{'0','0','1','0'},{'0','0','1','0'},{'0','0','1','0'},{'0','0','1','0'}}},
 
{{{'0','0','0','0'},{'0','1','1','0'},{'0','1','1','0'},{'0','0','0','0'}},//1 번 O형 블록
 {{'0','0','0','0'},{'0','1','1','0'},{'0','1','1','0'},{'0','0','0','0'}},
 {{'0','0','0','0'},{'0','1','1','0'},{'0','1','1','0'},{'0','0','0','0'}},
 {{'0','0','0','0'},{'0','1','1','0'},{'0','1','1','0'},{'0','0','0','0'}}},
 
{{{'0','0','0','0'},{'0','1','0','0'},{'1','1','1','0'},{'0','0','0','0'}},	//2 번 T형 블록
 {{'0','0','0','0'},{'0','1','0','0'},{'0','1','1','0'},{'0','1','0','0'}},
 {{'0','0','0','0'},{'0','0','0','0'},{'1','1','1','0'},{'0','1','0','0'}},
 {{'0','0','0','0'},{'0','1','0','0'},{'1','1','0','0'},{'0','1','0','0'}}},
 
{{{'0','0','0','0'},{'0','0','1','0'},{'1','1','1','0'},{'0','0','0','0'}},	//3 번 L형 블록
 {{'0','0','0','0'},{'0','1','0','0'},{'0','1','0','0'},{'0','1','1','0'}},
 {{'0','0','0','0'},{'0','0','0','0'},{'1','1','1','0'},{'1','0','0','0'}},
 {{'0','0','0','0'},{'1','1','0','0'},{'0','1','0','0'},{'0','1','0','0'}}},
 
{{{'0','0','0','0'},{'1','0','0','0'},{'1','1','1','0'},{'0','0','0','0'}},	//4 번 J형 블록
 {{'0','0','0','0'},{'0','1','1','0'},{'0','1','0','0'},{'0','1','0','0'}},
 {{'0','0','0','0'},{'0','0','0','0'},{'1','1','1','0'},{'0','0','1','0'}},
 {{'0','0','0','0'},{'0','1','0','0'},{'0','1','0','0'},{'1','1','0','0'}}}, 
 
{{{'0','0','0','0'},{'0','1','1','0'},{'1','1','0','0'},{'0','0','0','0'}},	//5 번 s형 블록	
 {{'0','0','0','0'},{'0','1','0','0'},{'0','1','1','0'},{'0','0','1','0'}},
 {{'0','0','0','0'},{'0','0','0','0'},{'0','1','1','0'},{'1','1','0','0'}},
 {{'0','0','0','0'},{'1','0','0','0'},{'1','1','0','0'},{'0','1','0','0'}}},
 
{{{'0','0','0','0'},{'1','1','0','0'},{'0','1','1','0'},{'0','0','0','0'}},	//6 번 z형 블록	
 {{'0','0','0','0'},{'0','0','1','0'},{'0','1','1','0'},{'0','1','0','0'}},
 {{'0','0','0','0'},{'0','0','0','0'},{'1','1','0','0'},{'0','1','1','0'}},
 {{'0','0','0','0'},{'0','1','0','0'},{'1','1','0','0'},{'1','0','0','0'}}}
};

bool is_started = false;
unsigned long lastFallTime = 0;
int fallDelay = 300;  
int blocknum, rotatenum;
int x = 12, y = 2, score = 0; // 현재 블록 위치 (왼쪽 상단 기준)
void print_board() {
  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) lc.setLed(3, i, j, board[i][j] != '0');
    for (int j = 8; j < 16; j++) lc.setLed(2, i, j - 8, board[i][j] != '0');
    for (int j = 16; j < 24; j++) lc.setLed(1, i, j - 16, board[i][j] != '0');
    for (int j = 24; j < 32; j++) lc.setLed(0, i, j - 24, board[i][j] != '0');
  }
}

void print_READY() {
  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) lc.setLed(3, i, j, READY[i][j] != '0');
    for (int j = 8; j < 16; j++) lc.setLed(2, i, j - 8, READY[i][j] != '0');
    for (int j = 16; j < 24; j++) lc.setLed(1, i, j - 16, READY[i][j] != '0');
    for (int j = 24; j < 32; j++) lc.setLed(0, i, j - 24, READY[i][j] != '0');
  }
}

void clear_screen() {
  for(int i = 0; i < 4; i++) {
    for(int j = 0; j < 8; j++) {
      for(int k = 0; k < 8; k++) {
        lc.setLed(i, j, k, false);
      }
    }
  }
}

void clear_board() {
  for (int i = 0; i < 8; i++)
    for (int j = 0; j < 32; j++)
      board[i][j] = '0';
  for(int i = 0; i < 8; i++) board[i][11] = '1'; //소환 및 한계선 표시
}

void draw_block(int val) {
  for (int i = 0; i < 4; i++)
    for (int j = 0; j < 4; j++)
      if (blocks[blocknum][rotatenum][i][j] == '1')
        board[y + i][x + j] = val ? '1' : '0';
}

bool can_move(int dx, int dy) {
  for (int i = 0; i < 4; i++)
    for (int j = 0; j < 4; j++)
      if (blocks[blocknum][rotatenum][i][j] == '1') {
        int nx = x + j + dx;
        int ny = y + i + dy;
        if (nx < 0 || nx >= 32 || ny >= 8 || ny < 0) return false;
        if (board[ny][nx] == '1') return false;
      }
  return true;
}

bool can_rotate() {
  for (int i = 0; i < 4; i++)
    for (int j = 0; j < 4; j++)
      if (blocks[blocknum][(rotatenum+1)%4][i][j] == '1') {
        int nx = x + j;
        int ny = y + i;
        if (nx < 0 || nx >= 32 || ny >= 8 || ny < 0) return false;
        if (board[ny][nx] == '1') return false;
      }
  return true;
}

void spawn_block() {
  blocknum = random(7);
  rotatenum = 0;
  //Serial.println(randnum);
  x = 12;
  y = 2;
  if(!(can_move(0,0))) {
    delay(10000);
    is_started = false;
    clear_board();
  }
}
void clear_lines() {
  for (int row = 12; row < 32; row++) {
    bool full = true;
    for (int col = 0; col < 8; col++) {
      if (board[col][row] == '0') {
        full = false;
        break;
      }
    }

    // 꽉 찬 줄 발견!
    if (full) {
      score += 10;
      // 위의 모든 줄을 아래로 한 줄씩 복사
      for (int y = row; y > 0; y--) {
        for (int x = 0; x < 8; x++) {
          board[x][y] = board[x][y-1];
        }
      }

      // 최상단 줄 초기화, 소환 및 한계선이 내려오는 것을 방지
      for (int x = 0; x < 8; x++) {
        board[x][11] = '1';
        board[x][12] = '0';
      }

      // 같은 줄 다시 검사 (연속 꽉 찬 줄)
      row--;
    }
  }
}

void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(A5));
  random(7);
  //Serial.println(random(7));
  pinMode(7, INPUT_PULLUP); // 시작 버튼 : 조이스틱 클릭
  for(int i = 0; i < 4; i++) {
    lc.shutdown(i, false);
    lc.setIntensity(i, 2);
    lc.clearDisplay(i);
  }
  spawn_block();
  clear_board();
}

void loop() {
  if (!is_started) {
    if (digitalRead(7) == 0) {
      is_started = true;
      // clear_board();
    }
    print_READY();
  }
  else {
  // 블록 지움
  draw_block(0);
  // 조이스틱 이동 처리
  int joyX = analogRead(A0);
  int joyY = analogRead(A1);
  if (joyX > 700 && can_move(0, -1)) {
    y--;
  } else if (joyX < 300 && can_move(0, 1)) {
    y++;
  }
  else if (joyY > 700 && can_move(1, 0)) {
    x++;
  }
  else if (joyY < 300 && can_rotate()) {
    rotatenum = (rotatenum+1)%4;
  }

  // 낙하 시간 도달 시
  if (millis() - lastFallTime > fallDelay) {
    if (can_move(1,0)) {
      x++;
    } else {
      draw_block(1); // 고정  
      clear_lines();
      spawn_block(); // 다음 블록
      score += 1;
      Serial.println(score);
    }
    lastFallTime = millis();
  }

  // 블록 그림
  draw_block(1);
  print_board();
  }
}